---
title: "Presentation Notes"
output: 
  html_document:
    toc: true
    keep_md: true
---

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
library(metaflu)
library(ggplot2)
library(dplyr)
library(doMC)
library(foreach)
library(tidyr)
library(purrr)
library(gridExtra)
library(abind)
library(printr)
#registerDoMC(cores = 20)
#devtools::install_github("renozao/doRNG", force = TRUE)
library(doRNG)
set.seed(123)
P <- rprojroot::find_package_root_file
library(parallel)
library(gganimate)
library(grid)
```

### Basic Run

- The base scenario in this report simulates a network of 200 farms, with around 50 chickens per farm. 

- Each simulation creates a randomly generated network of farms.

- Each simulation seeds one initial infected chicken at a random farm. 

- No culling practices are implemented.

```{r basic-run}
number_of_farms <- 200
number_of_chickens <- 50

  parms = list(
    beta = 1.44456,   #contact rate for direct transmission
    gamma = 0.167,  #recovery rate
    mu = 0,         #base mortality rate
    alpha = 0.4,      #disease mortality rate
    phi = 0,  #infectiousness of environmental virions
    eta = 0,     #degradation rate of environmental virions
    nu =  0.00,    #uptake rate of environmental virion
    sigma = 0,      #virion shedding rate
    omega = 0.03,   #movement rate
    rho = 0.85256,        #contact  nonlinearity 0=dens-dependent, 1=freq-dependent
    lambda = 0,     #force of infection from external sources
    tau_crit = 5,   #critical suveillance time
    I_crit = 5,     #threshold for reporting
    pi_report = 0, #reporting probability
    pi_detect = 0, #detection probability
    cull_time = 10,#time to culling
    network_type = "smallworld",
    network_parms = list(dim = 1, size = number_of_farms, nei = 2.33, p = 0.0596, multiple = FALSE, loops = FALSE),
    stochastic_network = TRUE
    )
  
#create patches
sims <- 1000

initial_cond_list <- lapply(seq_len(sims), function(x){
  return(basic_patches(number_of_chickens, number_of_farms))
})

base_seeded_list <- lapply(initial_cond_list, function(x){
  return(seed_initial_infection(x))
})

network_list <- lapply(seq_len(sims), function(x){
  return(make_net(parms$network_type, parms$network_parms))
})

basic_results_list <- pmap(list(base_seeded_list,network_list), function(x,y){
  parms$chi <- y
  return(mf_sim(init = x, parameters = parms, times = 1:365))
})

basic_results <- do.call("abind", basic_results_list)
  
#rm(basic_results_list)

```

- The two GIFs below are examples of the base network scenario:

  - This graphic shows a simulation run that resulted in a long epidemic (80 days). 
  
  - Nodes represent farms, with edges illustrating connections between farms. 

  - Black nodes represent farms with a normal chicken population, while red nodes indicate farms
  with at least one infected chicken. 
  
  
```{r basic-gif, eval = FALSE}

durs <- get_duration_array(basic_results) %>%
  arrange(desc(duration))

high_duration_sim <- durs$sim[1]
low_duration_sim <- durs$sim[sims-1]

create_gif(basic_results_list[[high_duration_sim]], P("inst","rome-presentation","base_high_dur_sim"))
create_gif(basic_results_list[[low_duration_sim]], P("inst","rome-presentation","base_low_dur_sim"))

```

![Long Duration Simulation](`r P("inst","rome-presentation","base_high_dur_sim.gif")`)


  - This graphic, on the other hand, shows a short duration simulation, where a seeded infection fails to spread throughout the network. 

![Short Duration Simulation](`r P("inst","rome-presentation","base_low_dur_sim.gif")`) 


```{r basic_table}
create_pres_df <- function(res_array, scenario){ #results, cull_time (string)

mean_prop_loss <- mean(get_proportion_loss(res_array)[,2])
mean_proportion_farms <- mean(get_number_farms(res_array)[,2]/200) #denominator: # of farms
mean_duration <- mean(get_duration_array(res_array)[,2])
mean_fraction_exposure <- mean(get_exposure_fraction(res_array)[,2])
prop_failure <- proportion_failed(get_failure_array(res_array))

df <- data.frame(scenario, mean_prop_loss, mean_proportion_farms, mean_duration, 
                 mean_fraction_exposure, prop_failure, stringsAsFactors = FALSE)

return(df)
}

basic_df <- create_pres_df(basic_results, "Base Scenario")

kable_table <- function(df){
  df %>% rename(`Scenario` = scenario, `Mean Proportion of Chickens Lost` = mean_prop_loss, `Mean Proportion of Farms Infected` = mean_proportion_farms, `Mean Duration of Epidemic (days)` = mean_duration, 
                 `Mean Exposure Index` = mean_fraction_exposure, `Proportion of Simulations that Failed to Spread` = prop_failure) %>%
  kable()
}


```

```{r visualize-basic}

create_graph_panel(basic_results, "Base Scenario")

```
<br>
<br>

```{r reduced-basic}
r_basic_results <- reduce_epi_array(basic_results)

r_basic_df <- create_pres_df(r_basic_results, "Base Scenario - Spread Only")

kable_table(bind_rows(basic_df,r_basic_df))

```


### Scalability Across Network Size

- The following graphs show that there does not appear to be a substantial relationship between increases in the number of farms in the network and our epidemic summary statistics. 

- However, as the number of chickens increase in each farm, there are noticeable patterns of change for epidemic duration, proportion of infected farms, proportion of chickens lost across the network, and fraction of possible exposure measure. 

- Due to the scalability of this model across network size, subsequent simulations are run with a network size of 200 farms of 50 chickens. 

- The duration of the epidemic is affected by the number of chickens in each farm, but not the number of farms in the network.

```{r load-netsize-experiment}
grand_df <- readRDS(P("inst","experiments","node_pop_df.rds"))

ggplot(data = grand_df) +
  geom_boxplot(aes(x = as.factor(chickens), y = duration)) +
  facet_wrap(~farms) +
  labs(title = "Duration of Epidemic by Number of Farms and Chickens", x = "Number of Chickens", y = "Days") +
  theme_minimal()

```
<br>
<br>
<br>
<br>
<br>

- The proportion of infected farms in a network is affected by the number of chickens in each farm, but not the number of farms in the network. 

```{r proportion-infected-farms}
grand_df$adj_farms <- grand_df$num_farms/grand_df$farms

ggplot(data = grand_df) +
  geom_boxplot(aes(x = as.factor(chickens), y = adj_farms)) +
  facet_wrap(~farms) +
  labs(title = "Proportion of Infected Farms by Number of Farms and Chickens", y = "Proportion of Infected Farms", x = "Number of Chickens per Farm") +
  theme_minimal()

```
<br>
<br>
<br>
<br>
<br>

- The proportion of chickens lost to infection or culling in a network is affected by the number of chickens in each farm, but not the number of farms in the network. 

```{r proportion-loss}
ggplot(data = grand_df) +
  geom_boxplot(aes(x = as.factor(chickens), y = prop_loss)) +
  facet_wrap(~farms) +
  labs(title = "Proportion of Chickens Lost", y = "Proportion of Chickens Lost", x = "Number of Chickens per Farm") +
  theme_minimal()

```
<br>
<br>
<br>
<br>
<br>

- The fraction of infectious exposure is affected by the number of chickens in each farm, but not the number of farms in the network. 


```{r measure-prop}
ggplot(data = grand_df) +
  geom_boxplot(aes(x = as.factor(chickens), y = exp_measure)) +
  facet_wrap(~farms) +
  labs(title = "Fraction of Infectious Exposure", y = "Infected-Chicken-Days over Total Chicken-Days", x = "Number of Chickens per Farm") +
  theme_minimal()

```

### Random Growth Run

- In the random growth scenario, 11% of farms grow from around 50 chickens to 500 chickens, resulting in a doubling of the total network chicken population. The location of these farms in the network is chosen at random. 

- Each simulation is seeded by choosing a random chicken to be infected. Since larger farms represent about 50% of the chicken population, there is about a 50% chance that the seeded infection will be on a larger farm.

```{r growth-no-culling}
growth_cond_list <- lapply(initial_cond_list, function(x){
  return(grow_patches_random(x))
})

growth_seeded_list <- lapply(growth_cond_list, function(x){
  return(seed_initial_infection(x))
})

random_growth_list <- pmap(list(growth_seeded_list, network_list), function(x,y){
  parms$chi <- y
  return(mf_sim(init = x, parameters = parms, times = 1:365))
})

random_growth <- do.call("abind", random_growth_list)

rm(random_growth_list)

rg_df <- create_pres_df(random_growth, "Growth in Random Farms")



```

```{r reduced-gnc}

r_rg <- reduce_epi_array(random_growth)

r_rg_df <- create_pres_df(r_rg, "Growth in Random Farms - Spread Only")

kable_table(bind_rows(rg_df, r_rg_df))


```
<br>
<br>

```{r visualize-gnc}

create_graph_panel(random_growth, "Random Growth Scenario")

```

### Localized Growth Run No Culling

- In the localized growth scenario, 11% of farms grow from around 50 chickens to 500 chickens, resulting in a doubling of the total network chicken population. The farms chosen to grow are adjacent nodes in a network, simulating the intensification of poultry production in one geographic, closely connected area. 

- Each simulation is seeded by choosing a random chicken to be infected. Since larger farms represent about 50% of the chicken population, there is about a 50% chance that the seeded infection will be on a larger farm.

```{r lgrowth-no-culling}

growth_cond_list <- lapply(initial_cond_list, function(x){
  return(grow_patches_clustered(x))
})

growth_seeded_list <- lapply(growth_cond_list, function(x){
  return(seed_initial_infection(x))
})

random_growth_list_c <- pmap(list(growth_seeded_list, network_list), function(x,y){
  parms$chi <- y
  return(mf_sim(init = x, parameters = parms, times = 1:365))
})

random_growth_c <- do.call("abind", random_growth_list_c)

rm(random_growth_list_c)

lg_df <- create_pres_df(random_growth_c, "Localized Farm Growth")


```

```{r r-lg-df}
r_lg <- reduce_epi_array(random_growth_c)

r_lg_df <- create_pres_df(r_lg, "Localized Farm Growth - Spread Only")

```

```{r non-cull-summary-df}

tot_df <- bind_rows(basic_df, r_basic_df, rg_df,r_rg_df, lg_df, r_lg_df)

kable_table(tot_df)

```
<br>
<br>

```{r visualize-gncr}

create_graph_panel(random_growth_c, "Localized Growth Scenario")

```


### Clustered Growth Run with Culling

- Culling is implemented as a two-step process:
    
    - Farms are first identified to be culled if a critical number of chickens have died in a certain time window.
    
    - Once a farm is identified, it is culled with an average speed parameterized by the *culling time* variable. When a farm is culled, all chickens (Susceptible, Infectious, and Recovered) are removed from that farm.

- The following graphs show how variation in the cull time parameter effects chicken loss, epidemic spread, duration of epidemic, and infected chicken exposure.

``` {r culling-graphs}
final_df <- readRDS(P("inst", "rome-presentation","cull-time-data.RDS"))

closs <- ggplot(data = final_df) +
  geom_point(aes(x = scenario, y = mean_prop_loss)) +
  labs(title = "Proportion of Loss", x = "Culling Time (Days)", y = "Proportion of Chickens Lost") +
  theme_minimal()

cfarms <- ggplot(data = final_df) +
  geom_point(aes(x = scenario, y = mean_proportion_farms)) +
  labs(title = "Proportion of Infected Farms", x = "Culling Time (Days)", y = "Proportion of Farms Infected") +
  theme_minimal()

cduration <- ggplot(data = final_df) +
  geom_point(aes(x = scenario, y = mean_duration)) +
  labs(title = "Duration of Epidemic ", x = "Culling Time (Days)", y = "Days") +
  theme_minimal()

cexposure <- ggplot(data = final_df) +
  geom_point(aes(x = scenario, y = mean_fraction_exposure)) +
  labs(title = "Exposure Index", x = "Culling Time (Days)", y = "Exposure Index") +
  theme_minimal()

lay <- rbind(c(1,2),
             c(3,4))

grid.arrange(closs, cfarms, cduration, cexposure, layout_matrix = lay, top=textGrob("Cull Time Parameter Analysis", gp = gpar(fontsize = 16)))

```

<div>
<div>
<div>
<div>

```{r culling-df}
final_df %>%  rename(`Culling Time (days)` = scenario, `Mean Proportion of Chickens Lost` = mean_prop_loss, `Mean Proportion of Farms Infected` = mean_proportion_farms, `Mean Duration of Epidemic (days)` = mean_duration, 
                 `Mean Exposure Index` = mean_fraction_exposure) %>%
  kable()

```
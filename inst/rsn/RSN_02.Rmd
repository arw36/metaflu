---
title: "Making Networks from Livestock Census Data- Ethiopia"
author: "Aishwarya Venkat"
date: "June 19, 2017"
output: html_document
---

```{r setup, include=FALSE}

library(rgdal);
library(maptools)
library(raster);
library(spatstat);
library(igraph);
library(reshape2);
library(rgeos);
library(dplyr);
library(RColorBrewer);
library(gridExtra);
library(knitr);

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
P <-rprojroot::find_rstudio_root_file
options(scipen=999)

# Functions to create voronoi tesselations

owin2Polygons <- function(x, id="1") {
  stopifnot(is.owin(x))
  x <- as.polygonal(x)
  closering <- function(df) { df[c(seq(nrow(df)), 1), ] }
  pieces <- lapply(x$bdry,
                   function(p) {
                     Polygon(coords=closering(cbind(p$x,p$y))) })
  z <- Polygons(pieces, id)
  return(z)
}

tess2SP <- function(x) {
  stopifnot(is.tess(x))
  y <- tiles(x)
  nom <- names(y)
  z <- list()
  for(i in seq(y))
    z[[i]] <- owin2Polygons(y[[i]], nom[i])
  return(SpatialPolygons(z))
}

# Read in data

path<-paste0("./data_toread/")
filenames<-gsub(".csv", "", list.files(path))

for(i in 1:length(filenames)){
  assign(filenames[i], read.csv(paste0(path, filenames[i], ".csv")))
}

## Loading Ethiopia shapefile data:

## OLD WAY--results in boundary issues
# ethiopia<-raster::getData('GADM', country='ETH', level=0)   # Country shp
# projection(ethiopia)<-wgs84

## NEW way, using Africa Open data dataset
## Also removes Lake Tana extent from the Ethiopia shapefile

url<-"https://africaopendata.org/dataset/76683f42-e659-4c57-8d4f-bc1debdf2720/resource/31a214fd-c5aa-4a39-bbc8-87bd8483032a/download/ethiopiaall.zip"

tmpdir <- tempdir()
file <- basename(url)
download.file(url, file)
unzip(file, exdir = tmpdir)

shapeFile <- paste0(tmpdir,"\\Ethiopia_All\\Eth_Zone_2013.shp")
ethiopia<-readOGR(shapeFile)

```

## Processing data

All Ethiopia's data is considered "valid coordinates". However, there is a bit of noise associated with these coordinates. So we figure out how the hierarchy of these households to figure out how they are grouped.

```{r eth_1}

# Bring in Ethiopia Admin 2 shapefile

wgs84<-"+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0";
ethiopia<-spTransform(ethiopia, wgs84)

## We will expand the country boundary by 50 km just to make sure none of the border points get cut off
#adindan<-"+proj=utm +zone=36 +ellps=clrk80 +units=m +no_defs"
#ethiopia_buf<-spTransform(ethiopia, CRS(adindan))
#ethiopia_buf<-gBuffer(ethiopia, byid=FALSE, 50000)
#ethiopia<-spTransform(ethiopia_buf, wgs84)

# Remove any data where X and Y are NA
completeFun <- function(data, desiredCols) {
  completeVec <- complete.cases(data[, desiredCols])
  return(data[completeVec, ])
}

lc_ethiopia<-completeFun(lc_ethiopia, c("latitude", "longitude"))
lc_ethiopia$id<-id(lc_ethiopia)
head(lc_ethiopia)

adm_strat<-lc_ethiopia %>% group_by(zone,woreda, kebele, hhid) %>% tally()
head(adm_strat)  

# Looks like they sampled anywhere between 1 - 12 households per kebele

# Since there are multiple points with one central location, let's use these points # to create n number of points per lat/long with different extents

tally_table<-lc_ethiopia %>% group_by(latitude, longitude, hhid) %>% tally()

# So for each point in the survey, sum(n)=# of points which need to be sampled, and
# hhid*n = total unique hhids to be assigned.

```

## Create Voronoi polygons 

From the above table, we know that the same lat/long can appear multiple times. The n here is the number of samples we need to generate within the Voronoi polygon surrounding the point.

For each polygon, we also need a unique list of hhids so we can match up points to the survey data.


```{r hh_adm}

ethiopia_owin<-as.owin(ethiopia)
pts_ppp<-ppp(lc_ethiopia$longitude, lc_ethiopia$latitude, window=ethiopia_owin)
dlet<-dirichlet(pts_ppp)
voronoi<-tess2SP(dlet)

allpts=NULL

# Set up spatialpoints layer for the unique lat/longs

pts_sp<-SpatialPoints(data.frame(x=tally_table$longitude, y=tally_table$latitude))

for(i in 1:length(voronoi)){
  
  # Extract polygon
  poly<-voronoi[i]
  
  # Figure out which points fall within this specific poly
  pts<-pts_sp[poly]
  
  # subset hhids by the unique lat/long combos in this df
  
  id_sub<-subset(lc_ethiopia, longitude %in% pts@coords[,1] & 
                     latitude %in% pts@coords[,2])$id

  sampledpts<-spsample(voronoi[i],n=length(id_sub),type="random")
  
  if(length(sampledpts)==1){
    sampledpts<-SpatialPointsDataFrame(sampledpts, 
                                     data=data.frame(newid=id_sub))
  } else{
  sampledpts<-SpatialPointsDataFrame(sampledpts, 
                                     data=data.frame(newid=sample(id_sub)))
  }
  
    if(i==1){
      allpts=sampledpts
    } else{
      allpts<-rbind(allpts, sampledpts)
    }
}

## THIS PORTION MIGHT THROW ERRORS SOMETIMES--because of issues sampling in 
## "zero-area" polygons. Run this chunk again if it doesn't work.

lc_eth_spdf<-allpts

par(mar=c(0,0,0,0), oma=c(0,0,0,0))
plot(voronoi, main=NULL);
plot(lc_eth_spdf, add=TRUE, main=NULL)

```

### Edit to come: matching points in Ethiopia/Eritrea border 

```{r hh_match}

missingrows<-lc_ethiopia[setdiff(lc_ethiopia$id, lc_eth_spdf$newid),]
missingrows<-SpatialPoints(data.frame(missingrows$longitude, missingrows$latitude))

plot(ethiopia); plot(missingrows, add=TRUE, col="red", fil="red", pch=16, cex=1)

# There is one point that is outside the border of Ethiopia. This is part of a contested boundary--need to figure out how to process

```

### Merge survey data with spatial data

```{r merge_surv_spat}

lc_eth_spdf@data<-merge(lc_eth_spdf@data, lc_ethiopia, 
                        by.x="newid", by.y="id", all=FALSE)

```

### Initial plots

```{r plot1, fig.height=10, fig.width=8}

# Create a layer-list
eth_outline <- list("sp.polygons", ethiopia, col = "grey")

par(oma=c(0,0,0,0), mar=c(0,0,0,0))

pal1 <- brewer.pal(n =4, name = "Reds"); 
chickens<-spplot(lc_eth_spdf, "chicken", 
       cuts = quantile(lc_eth_spdf$chicken[lc_eth_spdf$chicken>0]),
       col.regions = pal1, col = "transparent",
       sp.layout = eth_outline, auto.key=TRUE, key.space="right",
       par.settings = list(axis.line = list(col =  'transparent')),
       main="Chickens")

pal2 <- brewer.pal(n =4, name = "Greens"); 
cattle<-spplot(lc_eth_spdf, "cattle", 
       cuts = quantile(lc_eth_spdf$cattle[lc_eth_spdf$cattle>0]),
       col.regions = pal2, col = "transparent",
       sp.layout = eth_outline, auto.key=TRUE, key.space="right",
       par.settings = list(axis.line = list(col =  'transparent')),
       main="Cattle")


pal3 <- brewer.pal(n=4, name = "Greys"); 
sheep<-spplot(lc_eth_spdf, "sheep", 
       cuts = quantile(lc_eth_spdf$sheep[lc_eth_spdf$sheep>0]),
       col.regions = pal3, col = "transparent",
       sp.layout = eth_outline, auto.key=TRUE, key.space="right",
       par.settings = list(axis.line = list(col =  'transparent')),
       main="Sheep")

pal4 <- brewer.pal(n=4, name = "YlOrBr"); 
goats<-spplot(lc_eth_spdf, "goats", 
       cuts = quantile(lc_eth_spdf$goats[lc_eth_spdf$goats>0]),
       col.regions = pal4, col = "transparent",
       sp.layout = eth_outline, auto.key=TRUE, key.space="right",
       par.settings = list(axis.line = list(col =  'transparent')),
       main="Goats")

pal5 <- brewer.pal(n=2, name = "Blues"); 
otheran<-spplot(lc_eth_spdf, "otheran", 
       cuts = quantile(lc_eth_spdf$otheran[lc_eth_spdf$otheran>0])[3:5],
       col.regions = pal5, col = "transparent",
       sp.layout = eth_outline, auto.key=TRUE, key.space="right",
       par.settings = list(axis.line = list(col =  'transparent')),
       main="Other Animals")

grid.arrange(chickens, cattle, sheep, goats, otheran, ncol=2, nrow=3)

```

### Making a "Real-World Network" from the data

```{r distmat}

distMat<-round(spDists(as.matrix(lc_eth_spdf@coords), longlat=TRUE))  # dist in km
row.names(distMat)<-lc_eth_spdf$newid;
colnames(distMat)<-lc_eth_spdf$newid;

mat1<-distMat; 

weightsmat<-1/mat1; diag(weightsmat)<-0; weightsmat<-prop.table(weightsmat, 1)

## TEMPORARY LOGIC

mat1[mat1<25]=1  # All points <= 20 km apart are connected
mat1[mat1>=25]=0   # All points > 20 km apart are not connected

# Number of random values to replace, in our case 10% of complete data

N <- round(0.1*(nrow(mat1)*ncol(mat1)))   
mat1[sample(1:length(mat1), N)] <- 1

names(mat1)<-NULL; row.names(mat1)<-NULL;

#setdiff(mat2, mat1)

## Scale these weights so rowsums = 1
# mat2<-1/mat1; diag(mat2)<-0;
# mat3<-prop.table(mat2, 1)
# Now let's randomly rewire some 0s & 1s
#mat1$newvalues<-sample(c(0,1), size=nrow(mat1), replace=TRUE, prob=c(.99, 0.01))

```

### Set up initial condtions

```{r init_cond}

initial_cond <- cbind(lc_eth_spdf@data$chicken, 
                      matrix(0, ncol = 4, nrow = length(lc_eth_spdf@data$chicken)))

# Embed an infection at a random house

infected_patches <- sample(seq_len(nrow(initial_cond)), 1)
initial_cond[infected_patches, 2] <- 1
initial_cond[infected_patches, 1] <- initial_cond[infected_patches, 1] - 1

```

### Run mf_sim with this matrix

```{r runsim_parms}

knitr::opts_chunk$set(echo = FALSE, fig.width=10, fig.height=6, warning = FALSE)
library(metaflu)
library(ggplot2)
library(dplyr)
library(tidyr)
library(purrr)
library(gridExtra)
library(doRNG)

parms_realworld = list(
    beta = 0.004,   #contact rate for direct transmission
    gamma = 0.167,  #recovery rate
    mu = 0,         #base mortality rate
    alpha = 0.4,      #disease mortality rate
    phi = 0,  #infectiousness of environmental virions
    eta = 0,     #degradation rate of environmental virions
    nu =  0.00,    #uptake rate of environmental virion
    sigma = 0,      #virion shedding rate
    omega = 0.03,   #movement rate
    rho = 0,        #contact  nonlinearity 0=dens-dependent, 1=freq-dependent
    lambda = 0,     #force of infection from external sources
    tau_crit = 0,   #critical suveillance time
    I_crit = 0,     #threshold for reporting
    pi_report = 0, #reporting probability
    pi_detect = 0, #detection probability
    cull_time = 1, #culling time
    chi=mat1   #network input
)

parms_smallworld = list(
    beta = 0.004,   #contact rate for direct transmission
    gamma = 0.167,  #recovery rate
    mu = 0,         #base mortality rate
    alpha = 0.4,      #disease mortality rate
    phi = 0,  #infectiousness of environmental virions
    eta = 0,     #degradation rate of environmental virions
    nu =  0.00,    #uptake rate of environmental virion
    sigma = 0,      #virion shedding rate
    omega = 0.03,   #movement rate
    rho = 0,        #contact  nonlinearity 0=dens-dependent, 1=freq-dependent
    lambda = 0,     #force of infection from external sources
    tau_crit = 0,   #critical suveillance time
    I_crit = 0,     #threshold for reporting
    pi_report = 0, #reporting probability
    pi_detect = 0, #detection probability
    cull_time = 1, #culling time
    network_type = "smallworld",
    network_parms = list(dim = 1, size = length(lc_eth_spdf@data$chicken), 
                         nei = 2.33, p = 0.0596, multiple = FALSE, loops = FALSE),
    stochastic_network = TRUE
)

```

### RSN model

```{r results_realworld}

library(grid); library(gridExtra);

res_realworld <- mf_sim(init = initial_cond, 
                        parameters = parms_realworld, times=0:365, n_sims = 20)

create_graph_panel(res_realworld, "Real World")

# dur_rw <- get_duration_array(res_realworld)
# s_rw <- get_susceptibles_array(res_realworld)
# i_rw <- get_infectious_array(res_realworld)
# r_rw <- get_recovered_array(res_realworld)
# fail_rw <- get_failure_array(res_realworld)
# all_sims_sw<-get_all_sims(res_smallworld)
# s <- basic_results["S",,,1]
# i <- basic_results["I",,,1]
# View(i)
# rm(basic_results)
  
```

### Small World model

```{r results_smallworld}

res_smallworld <- mf_sim(init = initial_cond, 
                        parameters = parms_smallworld, times=0:365, n_sims = 20)

create_graph_panel(res_smallworld, "Small World")

# dur_sw <- get_duration_array(res_smallworld)
# s_sw <- get_susceptibles_array(res_smallworld)
# i_sw <- get_infectious_array(res_smallworld)
# r_sw <- get_recovered_array(res_smallworld)
# fail_sw <- get_failure_array(res_smallworld)
# all_sims_sw<-get_all_sims(res_smallworld)
# s <- basic_results["S",,,1]
# i <- basic_results["I",,,1]
# View(i)
# rm(basic_results)
  
#and get_all_sims: Error in lapply(seq_len(dim(results)[4]), function(x) results[compartment,  :   argument "results" is missing, with no default. 

```


### Making small world and real world networks

```{r make_nets}

rw<-graph_from_adjacency_matrix(mat1); 
#E(rw)$weight<-weightsmat

#rws<-igraph::simplify(rw, remove.multiple = FALSE, remove.loops = TRUE)
rws<-rw
V(rws)$chicken<-lc_eth_spdf@data$chicken

ws<-watts.strogatz.game(dim = 1, size = nrow(lc_eth_spdf@data), nei = 2.33, 
                        p = 0.0596, multiple = FALSE, loops = FALSE)
V(ws)$chicken<-lc_eth_spdf@data$chicken

```

### Clustering coefficient

```{r rsn_clust}

data.frame(Model=c("Real World", "Small World"), 
           Value=round(c(transitivity(rws), transitivity(ws)), 3))

```

### Path lengths

```{r rsn_dist}

data.frame(Model=c("Real World", "Small World"), 
           Value=round(c(mean_distance(rws), mean_distance(ws)), 3))

```

### Closeness centrality

Closeness centrality is defined as how many steps are required to access every other vertex from a given vertex.

```{r rsn_close}

data.frame(Model=c("Real World", "Small World"), 
           Value=round(c(mean(closeness(rws)), mean(closeness((ws)))), 6))

```

### Assortativity by farm size

Assortativity is the tendency of nodes to connect to others who are similar on some variable

```{r rsn_assort}

data.frame(Model=c("Real World", "Small World"), 
           Value=round(c(assortativity(rws, V(rws)$chicken, directed=F),
                         assortativity(ws, V(ws)$chicken, directed=F)), 6))

```

### Community Modularity

```{r communities}

fc_1 <- fastgreedy.community(as.undirected(rws))
fc_2 <- fastgreedy.community(as.undirected(ws))

data.frame(Algorithm=c("Fast Greedy"),
           `Modularity: Real World`=
             round(c(modularity(rws, fc_1$membership)), 5),
           `Modularity: Small World`=
             round(c(modularity(ws, fc_2$membership)), 5))

```

### Community Membership Maps

```{r membership_maps}

lc_eth_spdf$memb_fg<-as.factor(fc_1$membership)
#lc_eth_spdf$memb_lec<-as.factor(rws_memb$`Leading eigenvector`)

spplot(lc_eth_spdf, "memb_fg", 
       sp.layout = eth_outline, auto.key=TRUE, key.space="right",
       par.settings = list(axis.line = list(col =  'transparent')),
       main="Fast-Greedy Membership")

```


```{r old_potentiallyuseful, include=FALSE}

# # data.frame(Algorithm=c("Fast Greedy", "Leading Eigenvector"),
#            `Modularity: Real World`=
#              round(c(modularity(rws, rws_memb$`Fast greedy`),
#                      modularity(rws, rws_memb$`Leading eigenvector`)), 5),
#            `Modularity: Small World`=
#              round(c(modularity(ws, ws_memb$`Fast greedy`), 
#                      modularity(ws, ws_memb$`Leading eigenvector`)), 5))

#rn.rewired <- rewire(rn, each_edge(prob=0.1))
#plot(rn.rewired, vertex.size=10, vertex.label=NA)
# V(rws)$color <- rainbow(3)[rws_memb$'Fast greedy'+1]                
# l <- layout_in_circle(rws)
# plot.new()
# plot(rws, layout=l)

# memb_lec<-spplot(lc_eth_spdf, "memb_lec", 
#        sp.layout = eth_outline, auto.key=TRUE, key.space="right",
#        par.settings = list(axis.line = list(col =  'transparent')),
#        main="Leading Eigenvector Membership")

# grid.arrange(memb_fg, memb_lec, ncol=2, nrow=1)

```